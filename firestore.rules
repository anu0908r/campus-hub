/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model for all private data,
 * while allowing public read access to shared educational content. The primary goal is to
 * isolate each user's data (profiles, notes, chat history) to prevent unauthorized access,
 * ensuring privacy and data integrity.
 *
 * Data Structure: The data is organized into two main categories:
 * 1. User-Specific Data: All data private to a user is nested under the `/users/{userId}`
 *    path. This includes their profile, private notes (`/notes`), and chatbot conversations
 *    (`/chat_messages`). This path-based ownership is the cornerstone of the security model.
 * 2. Public Content: Shared educational materials like `/courses` and their associated
 *    `/resources` are stored in top-level collections, making them globally accessible for
 *    reading by any authenticated user.
 *
 * Key Security Decisions:
 * - User data is strictly private. A user can only access documents within their own
 *   `/users/{userId}` data tree.
 * - Listing users is disallowed to prevent user enumeration and protect privacy.
 * - Shared content (`/courses`, `/resources`) is read-only for all authenticated users.
 *   Writes to these collections are disabled by default, assuming they are managed by
 *   administrators via a trusted server environment (e.g., Cloud Functions, Admin SDK).
 * - All operations require user authentication. There is no anonymous public access.
 *
 * Denormalization for Authorization: Security is optimized by using path-based ownership.
 * Placing a user's private data under a path containing their UID (e.g., /users/{userId}/notes)
 * allows for simple, fast, and highly secure rules without needing extra document reads (`get()`).
 * Additionally, documents in user subcollections (like `Note` and `ChatMessage`) contain a `userId`
 * field, which is validated against the path to ensure relational integrity.
 *
 * Structural Segregation: The ruleset leverages separate collections for private and public
 * data. Private data (`notes`, `chat_messages`) is stored in user subcollections, while
 * public data (`courses`) is in a top-level collection. This separation is more secure and
 * performant than using a single collection with access control flags.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the foundation of the user ownership model.
     * @param userId The UID to check against the authenticated user.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Checks if the document being accessed already exists.
     * Used in update/delete operations to prevent acting on non-existent data.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Combines ownership check with an existence check.
     * Ensures that state-changing operations (update, delete) only affect
     * existing documents owned by the user.
     * @param userId The UID to verify ownership against.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * Validates that the user is creating their own user profile document and
     * that the document's internal `id` field matches their UID.
     * @param userId The UID from the path, to be matched with auth UID.
     */
    function isCreatingSelf(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }

    /**
     * Validates that an incoming user-owned subcollection document has its
     * internal `userId` field correctly set to the owner's UID.
     * @param userId The UID from the path, which defines the owner.
     */
    function isCreatingOwnedDoc(userId) {
      return isOwner(userId) && request.resource.data.userId == userId;
    }

    /**
     * Validates that a user-owned document's internal `id` field
     * is not being changed during an update.
     */
    function isNotChangingId() {
      return request.resource.data.id == resource.data.id;
    }
    
    /**
     * Validates that a user-owned document's internal `userId` field
     * is not being changed during an update.
     */
    function isNotChangingOwner() {
      return request.resource.data.userId == resource.data.userId;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Manages user profile data.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own profile document.
     * @allow (get, update) An authenticated user accessing or modifying their own profile.
     * @deny (list) Any user attempting to list all user profiles.
     * @deny (get) A user trying to read another user's profile.
     * @principle Restricts access to a user's own data tree and enforces self-creation.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isCreatingSelf(userId);
      allow update: if isExistingOwner(userId) && isNotChangingId();
      allow delete: if isExistingOwner(userId);

      /**
       * @description Manages user-created study notes.
       * @path /users/{userId}/notes/{noteId}
       * @allow (create, list, get) A user creating, listing, or reading their own notes.
       * @deny (get) A user trying to read another user's notes.
       * @deny (create) A user trying to create a note under another user's profile.
       * @principle Enforces document ownership within a user's private data tree.
       */
      match /notes/{noteId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isCreatingOwnedDoc(userId);
        allow update: if isExistingOwner(userId) && isNotChangingOwner();
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Manages a user's conversation history with the AI chatbot.
       * @path /users/{userId}/chat_messages/{messageId}
       * @allow (create, list, get) A user managing messages in their own chat history.
       * @deny (get) A user trying to read another user's chat history.
       * @deny (delete) A user trying to delete a message from another user's chat.
       * @principle Enforces strict ownership over private conversation data.
       */
      match /chat_messages/{messageId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isCreatingOwnedDoc(userId);
        allow update: if isExistingOwner(userId) && isNotChangingOwner();
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description Manages global course information.
     * @path /courses/{courseId}
     * @allow (get, list) Any authenticated user can read course information.
     * @deny (create, update, delete) All write operations are denied for clients.
     * @principle Provides public read access for shared data while securing it from modification.
     */
    match /courses/{courseId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;

      /**
       * @description Manages study resources associated with a course.
       * @path /courses/{courseId}/resources/{resourceId}
       * @allow (get, list) Any authenticated user can read course resources.
       * @deny (create, update, delete) All write operations are denied for clients.
       * @principle Provides public read access to data related to publicly visible content.
       */
      match /resources/{resourceId} {
        allow get: if isSignedIn();
        allow list: if isSignedIn();
        allow create: if false;
        allow update: if false;
        allow delete: if false;
      }
    }
  }
}